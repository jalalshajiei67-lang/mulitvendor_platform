name: Deploy Staging
on:
  # Deploy after build workflow completes
  workflow_run:
    workflows: ["Build and Push Docker Images"]
    types:
      - completed
    branches:
      - staging
  # Also allow manual trigger
  workflow_dispatch:
    inputs:
      skip_build_check:
        description: 'Skip waiting for build (use if images already exist)'
        required: false
        default: 'false'
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    # Only deploy if build workflow succeeded
    if: |
      github.event.workflow_run.conclusion == 'success' ||
      github.event.inputs.skip_build_check == 'true' ||
      github.event_name == 'workflow_dispatch'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Copy files to VPS
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: ${{ secrets.STAGING_USERNAME }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          source: "."
          target: "/root/indexo-staging"
          rm: true

      - name: Deploy via SSH
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: ${{ secrets.STAGING_USERNAME }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          script: |
            # Navigate to project directory
            cd /root/indexo-staging
            
            # Generate SECRET_KEY if .env.staging doesn't exist or SECRET_KEY is invalid
            if [ ! -f .env.staging ] || ! grep -q "SECRET_KEY=django-insecure-" .env.staging; then
              SECRET_KEY=$(openssl rand -base64 48 | tr -d '\n')
              cat > .env.staging << EOF
            DB_NAME=multivendor_db_staging
            DB_USER=postgres
            DB_PASSWORD=MySecurePassword123!
            DB_HOST=db
            DB_PORT=5432
            REDIS_HOST=redis
            REDIS_PORT=6379
            SECRET_KEY=django-insecure-${SECRET_KEY}
            DEBUG=False
            ALLOWED_HOSTS=localhost,127.0.0.1,backend,staging.indexo.ir,api-staging.indexo.ir
            MAIN_DOMAIN=staging.indexo.ir
            API_DOMAIN=api-staging.indexo.ir
            CSRF_TRUSTED_ORIGINS=https://staging.indexo.ir,https://api-staging.indexo.ir
            CORS_ALLOWED_ORIGINS=https://staging.indexo.ir,https://api-staging.indexo.ir
            CORS_ALLOW_ALL_ORIGINS=False
            NODE_ENV=production
            NUXT_HOST=0.0.0.0
            NUXT_PORT=3000
            NUXT_PUBLIC_API_BASE=https://api-staging.indexo.ir/api
            EOF
            fi
            
            # Set Docker registry variables for image pulling
            # These will be used by docker-compose.staging.yml
            echo "DOCKER_REGISTRY=${{ env.REGISTRY }}" >> .env.staging
            echo "DOCKER_REPO=${{ env.IMAGE_PREFIX }}" >> .env.staging
            echo "IMAGE_TAG=staging" >> .env.staging
            
            # Copy .env.staging to .env for Docker Compose variable substitution
            cp .env.staging .env
            
            # Authenticate with GitHub Container Registry
            echo "ðŸ” Authenticating with GitHub Container Registry..."
            # Try using Personal Access Token first (recommended for private repos)
            if [ -n "${{ secrets.GHCR_TOKEN }}" ]; then
              echo "${{ secrets.GHCR_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin
            elif [ -n "${{ secrets.GITHUB_TOKEN }}" ]; then
              # Fallback to GITHUB_TOKEN (works for public repos)
              echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin || {
                echo "âš ï¸  GITHUB_TOKEN authentication failed. Trying public pull..."
              }
            else
              echo "âš ï¸  No authentication token found. Trying public pull (may fail for private repos)..."
            fi
            
            # Stop and remove old containers using docker compose (more reliable)
            docker compose -f docker-compose.staging.yml down || true
            
            # Also manually stop containers with staging suffix (in case compose down fails)
            docker stop multivendor_backend_staging multivendor_frontend_staging multivendor_db_staging multivendor_redis_staging multivendor_nginx_staging traefik_staging 2>/dev/null || true
            docker rm multivendor_backend_staging multivendor_frontend_staging multivendor_db_staging multivendor_redis_staging multivendor_nginx_staging traefik_staging 2>/dev/null || true
            
            # Ensure network exists (will be created by docker compose if not exists)
            docker network create multivendor_network --driver bridge || true
            
            # Pull latest images from registry (no build needed!)
            echo "ðŸ“¥ Pulling latest images from registry..."
            
            # Wait for images to be available (with retry)
            MAX_RETRIES=10
            RETRY_COUNT=0
            IMAGE_BACKEND="${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-backend:staging"
            IMAGE_FRONTEND="${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-frontend:staging"
            
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if docker manifest inspect "$IMAGE_BACKEND" > /dev/null 2>&1 && \
                 docker manifest inspect "$IMAGE_FRONTEND" > /dev/null 2>&1; then
                echo "âœ… Images are available!"
                break
              fi
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "â³ Waiting for images... ($RETRY_COUNT/$MAX_RETRIES)"
              sleep 10
            done
            
            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
              echo "âŒ Images not found after $MAX_RETRIES attempts"
              echo "ðŸ’¡ Make sure 'Build and Push Docker Images' workflow completed successfully"
              exit 1
            fi
            
            # Pull images
            docker compose -f docker-compose.staging.yml pull backend frontend
            
            # Start database first to fix password if needed (stateless solution)
            echo "Starting database container..."
            docker compose -f docker-compose.staging.yml up -d db
            
            # Wait for database to be ready
            echo "Waiting for database to be ready..."
            for i in {1..30}; do
              if docker exec multivendor_db_staging pg_isready -U postgres > /dev/null 2>&1; then
                echo "Database is ready!"
                break
              fi
              echo "  Waiting for database... ($i/30)"
              sleep 2
            done
            
            # Read DB_PASSWORD from .env.staging
            DB_PASSWORD=$(grep "^DB_PASSWORD=" .env.staging | cut -d '=' -f2 | tr -d '"' | tr -d "'" | xargs)
            
            # Stateless password fix: Check and reset if needed
            echo "Checking database password..."
            if ! docker exec -e PGPASSWORD="$DB_PASSWORD" multivendor_db_staging psql -U postgres -c "SELECT 1;" > /dev/null 2>&1; then
              echo "Password mismatch detected. Resetting database password (stateless fix)..."
              
              # Stop database to modify pg_hba.conf
              docker stop multivendor_db_staging
              
              # Temporarily enable trust authentication
              docker run --rm \
                -v indexo-staging_postgres_data_staging:/var/lib/postgresql/data \
                postgres:15-alpine \
                sh -c "
                  cp /var/lib/postgresql/data/pg_hba.conf /var/lib/postgresql/data/pg_hba.conf.backup 2>/dev/null || true
                  echo 'local   all             all                                     trust' > /var/lib/postgresql/data/pg_hba.conf
                  echo 'host    all             all             127.0.0.1/32            trust' >> /var/lib/postgresql/data/pg_hba.conf
                  echo 'host    all             all             ::1/128                 trust' >> /var/lib/postgresql/data/pg_hba.conf
                  echo 'host    all             all             0.0.0.0/0               trust' >> /var/lib/postgresql/data/pg_hba.conf
                " || echo "Warning: Could not modify pg_hba.conf"
              
              # Start database with trust auth
              docker start multivendor_db_staging
              sleep 5
              
              # Wait for database
              for i in {1..30}; do
                if docker exec multivendor_db_staging pg_isready -U postgres > /dev/null 2>&1; then
                  break
                fi
                sleep 1
              done
              
              # Reset password
              docker exec multivendor_db_staging psql -U postgres -c "ALTER USER postgres WITH PASSWORD '$DB_PASSWORD';" || echo "Warning: Could not reset password"
              
              # Restore pg_hba.conf
              docker stop multivendor_db_staging
              docker run --rm \
                -v indexo-staging_postgres_data_staging:/var/lib/postgresql/data \
                postgres:15-alpine \
                sh -c "
                  if [ -f /var/lib/postgresql/data/pg_hba.conf.backup ]; then
                    cp /var/lib/postgresql/data/pg_hba.conf.backup /var/lib/postgresql/data/pg_hba.conf
                  else
                    echo 'local   all             all                                     md5' > /var/lib/postgresql/data/pg_hba.conf
                    echo 'host    all             all             127.0.0.1/32            md5' >> /var/lib/postgresql/data/pg_hba.conf
                    echo 'host    all             all             ::1/128                 md5' >> /var/lib/postgresql/data/pg_hba.conf
                    echo 'host    all             all             0.0.0.0/0               md5' >> /var/lib/postgresql/data/pg_hba.conf
                  fi
                " || echo "Warning: Could not restore pg_hba.conf"
              
              # Start database with password auth
              docker start multivendor_db_staging
              sleep 3
              echo "Database password reset complete"
            else
              echo "Database password is correct"
            fi
            
            # Deploy all services (pulls images, no build needed!)
            echo "ðŸš€ Starting all services with pre-built images..."
            docker compose -f docker-compose.staging.yml up -d
            
            # Clean up unused images
            docker image prune -f
